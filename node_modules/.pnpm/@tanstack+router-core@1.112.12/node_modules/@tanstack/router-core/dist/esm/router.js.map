{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import type { ParsedLocation } from './location'\nimport type { DeferredPromiseState } from './defer'\nimport type {\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  Updater,\n} from './utils'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteMask,\n} from './route'\nimport type { Store } from '@tanstack/store'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type { Manifest } from './manifest'\nimport type { StartSerializer } from './serializer'\nimport type { AnySchema } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { SearchParser, SearchSerializer } from './searchParams'\n\ndeclare global {\n  interface Window {\n    __TSR_ROUTER__?: AnyRouter\n  }\n}\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // router: Router\n}\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   *\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => TDehydrated\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => void\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  defaultSsr?: boolean\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?: boolean\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string>\n}\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  _fromLocation?: ParsedLocation\n  href?: string\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport type RouterEvents = {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onInjectedHtml: {\n    type: 'onInjectedHtml'\n    promise: Promise<string>\n  }\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface MatchedRoutesResult {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n}\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    Router<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    Router<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n  locationToParse?: HistoryLocation,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  next: ParsedLocation,\n  dest?: BuildNextOptions,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => AnyRouteMatch\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSrr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  streamValue: (key: string, value: any) => void\n  streamedKeys: Set<string>\n  onMatchSettled: (opts: { router: AnyRouter; match: AnyRouteMatch }) => any\n}\n\nexport interface Router<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  routeTree: TRouteTree\n  options: RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >\n  __store: Store<RouterState<TRouteTree>>\n  navigate: NavigateFn\n  history: TRouterHistory\n  state: RouterState<TRouteTree>\n  isServer: boolean\n  clientSsr?: {\n    getStreamedValue: <T>(key: string) => T | undefined\n  }\n  looseRoutesById: Record<string, AnyRoute>\n  latestLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  isScrollRestoring: boolean\n  resetNextScroll: boolean\n  isScrollRestorationSetup: boolean\n  ssr?: {\n    manifest: Manifest | undefined\n    serializer: StartSerializer\n  }\n  serverSsr?: ServerSrr\n  basepath: string\n  routesById: RoutesById<TRouteTree>\n  routesByPath: RoutesByPath<TRouteTree>\n  flatRoutes: Array<AnyRoute>\n  parseLocation: ParseLocationFn<TRouteTree>\n  getMatchedRoutes: GetMatchRoutesFn\n  emit: EmitFn\n  load: LoadFn\n  commitLocation: CommitLocationFn\n  buildLocation: BuildLocationFn\n  startTransition: StartTransitionFn\n  subscribe: SubscribeFn\n  matchRoutes: MatchRoutesFn\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  >\n  getMatch: GetMatchFn\n  updateMatch: UpdateMatchFn\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  >\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >\n  invalidate: InvalidateFn<\n    Router<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  >\n  loadRouteChunk: LoadRouteChunkFn\n  resolveRedirect: ResolveRedirect\n  buildRouteTree: () => void\n  clearCache: ClearCacheFn<\n    Router<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  >\n}\n\nexport type AnyRouterWithContext<TContext> = Router<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = Router<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types: Array<string>\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\nexport interface ExtractedBaseEntry {\n  dataType: '__beforeLoadContext' | 'loaderData'\n  type: string\n  path: Array<string>\n  id: number\n  matchIndex: number\n}\n\nexport interface ExtractedStream extends ExtractedBaseEntry {\n  type: 'stream'\n  streamState: StreamState\n}\n\nexport interface ExtractedPromise extends ExtractedBaseEntry {\n  type: 'promise'\n  promiseState: DeferredPromiseState<any>\n}\n\nexport type ExtractedEntry = ExtractedStream | ExtractedPromise\n\nexport type StreamState = {\n  promises: Array<ControlledPromise<string | null>>\n}\n\nexport type TrailingSlashOption = 'always' | 'never' | 'preserve'\n\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n"],"names":[],"mappings":"AAwtBO,SAAS,sBAAsB,KAAc;AAClD,MAAI,eAAe,OAAO;AACxB,UAAM,MAAM;AAAA,MACV,MAAM,IAAI;AAAA,MACV,SAAS,IAAI;AAAA,IACf;AAEI,QAAA,QAAQ,IAAI,aAAa,eAAe;AACxC,UAAY,QAAQ,IAAI;AAAA,IAAA;AAGrB,WAAA;AAAA,EAAA;AAGF,SAAA;AAAA,IACL,MAAM;AAAA,EACR;AACF;AA2BO,SAAS,sBAAsB,aAGnC;AACD,QAAM,eAAe,YAAY;AACjC,QAAM,aAAa,YAAY;AACzB,QAAA,eAAc,6CAAc,cAAa,WAAW;AACpD,QAAA,eAAc,6CAAc,UAAS,WAAW;AAChD,QAAA,eAAc,6CAAc,UAAS,WAAW;AACtD,SAAO,EAAE,cAAc,YAAY,aAAa,aAAa,YAAY;AAC3E;"}